/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.ground.persistence.remote.firebase.protobuf

import com.google.firebase.firestore.DocumentSnapshot
import com.google.protobuf.GeneratedMessageLite
import kotlin.reflect.KClass
import kotlin.reflect.full.isSubclassOf
import timber.log.Timber

typealias MessageBuilder = GeneratedMessageLite.Builder<*, *>

/**
 * Returns a new instance of the specified [Message] populated with the document's id and data.
 *
 * Corresponding proto fields are matched based on their fields names. Several special rules are
 * also applied:
 * * Invalid or unrecognized are ignored.
 * * When populating `map<String, Message>`, the converter attempts to set the map key in the "id"
 *   field of the `Message` map values.
 *
 * This implementation is tightly bound to the implementation of code generated by
 * protobuf-kotlin-lite. Future versions of the library may require changes to this util.
 */
fun DocumentSnapshot.toMessage(messageType: KClass<Message>): Message {
  val builder = messageType.newBuilderForType()
  builder.setOrLog(ID_FIELD_NAME, id)
  data.copyInto(builder)
  return builder.build()
}

private fun FirestoreMap?.toMessage(messageType: KClass<Message>): Message {
  val builder = messageType.newBuilderForType()
  copyInto(builder)
  return builder.build()
}

private fun FirestoreMap?.copyInto(builder: MessageBuilder) {
  this?.forEach { it.copyInto(builder) }
}

private fun FirestoreMapEntry.copyInto(builder: MessageBuilder) {
  toMessageField(builder.javaClass.kotlin)?.also { (k, v) ->
    if (v is MessageMap) builder.putAllOrLog(k, v) else builder.setOrLog(k, v)
  }
}

private fun FirestoreMapEntry.toMessageField(builderType: KClass<MessageBuilder>): MessageField? =
  try {
    val fieldName: MessageFieldName = key
    val fieldValue = value.toMessageValue(builderType, fieldName)
    MessageField(fieldName, fieldValue)
  } catch (e: Throwable) {
    Timber.e(e, "Skipping incompatible Firestore value. ${javaClass}: $key=$value")
    null
  }

private fun FirestoreMap.toMessageMap(mapValueType: KClass<*>): MessageMap =
  map { (key: FirestoreValue, value: FirestoreValue) -> key to value.toMessageValue(mapValueType) }
    .toMap()

@Suppress("UNCHECKED_CAST")
private fun FirestoreValue.toMessageValue(
  builderType: KClass<MessageBuilder>,
  fieldName: String,
): MessageValue {
  val fieldType = builderType.getFieldTypeByName(fieldName)
  return if (fieldType.isSubclassOf(Map::class)) {
    (this as FirestoreMap).toMessageMap(builderType.getMapValueType(fieldName))
  } else {
    toMessageValue(fieldType)
  }
}

@Suppress("UNCHECKED_CAST")
private fun FirestoreValue.toMessageValue(targetType: KClass<*>): MessageValue =
  if (targetType == String::class) {
    this as String
  } else if (targetType.isSubclassOf(GeneratedMessageLite::class)) {
    (this as FirestoreMap).toMessage(targetType as KClass<Message>)
  } else {
    throw UnsupportedOperationException("Unsupported message field type $targetType")
    // TODO(#1748): Handle arrays, GeoPoint, int, and other types.
  }
