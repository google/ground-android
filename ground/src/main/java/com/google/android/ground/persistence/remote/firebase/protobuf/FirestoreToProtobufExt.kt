/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.ground.persistence.remote.firebase.protobuf

import com.google.firebase.firestore.DocumentSnapshot
import com.google.protobuf.GeneratedMessageLite
import java.lang.IllegalArgumentException
import kotlin.reflect.KClass
import kotlin.reflect.full.isSubclassOf
import timber.log.Timber

typealias MessageBuilder = GeneratedMessageLite.Builder<*, *>

/**
 * Returns a new instance of the specified [Message] populated with the document's id and data.
 *
 * Corresponding proto fields are matched based on their fields numbers. Several special rules are
 * also applied:
 * * Unrecognized fields and fields of incompatible types are ignored.
 * * When populating `map<String, Message>`, the converter attempts to set the map key in the "id"
 *   field of the `Message` map values.
 *
 * This implementation is tightly bound to the implementation of code generated by
 * protobuf-kotlin-lite. Future versions of the library may require changes to this util.
 */
@Suppress("UNCHECKED_CAST")
fun <T : Message> KClass<T>.parseFrom(documentSnapshot: DocumentSnapshot): T {
  val builder = newBuilderForType()
  builder.setOrLog(ID_FIELD_NAME, documentSnapshot.id)
  documentSnapshot.data.copyInto(builder)
  return builder.build() as T
}

private fun KClass<Message>.parseFrom(map: FirestoreMap?): Message {
  val builder = newBuilderForType()
  map.copyInto(builder)
  return builder.build()
}

private fun FirestoreMap?.copyInto(builder: MessageBuilder) {
  this?.forEach { it.copyInto(builder) }
}

private fun FirestoreMapEntry.copyInto(builder: MessageBuilder) {
  toMessageField(builder::class)?.also { (k, v) ->
    if (v is MessageMap) builder.putAllOrLog(k, v) else builder.setOrLog(k, v)
  }
}

private fun FirestoreMapEntry.toMessageField(
  builderType: KClass<out MessageBuilder>
): MessageField? =
  try {
    val fieldNumber = key.toMessageFieldNumber()
    val fieldName = builderType.getFieldName(fieldNumber)
    val fieldValue = value.toMessageValue(builderType, fieldName)
    MessageField(fieldName, fieldValue)
  } catch (e: Throwable) {
    Timber.v(e, "Skipping incompatible Firestore value. ${javaClass}: $key=$value")
    null
  }

private fun FirestoreKey.toMessageFieldNumber() =
  toIntOrNull() ?: throw IllegalArgumentException("Non-numeric document key $this")

private fun FirestoreMap.toMessageMap(mapValueType: KClass<*>): MessageMap =
  map { (key: FirestoreValue, value: FirestoreValue) -> key to value.toMessageValue(mapValueType) }
    .toMap()

@Suppress("UNCHECKED_CAST")
private fun FirestoreValue.toMessageValue(
  builderType: KClass<out MessageBuilder>,
  fieldName: MessageFieldName,
): MessageValue {
  val fieldType = builderType.getFieldTypeByName(fieldName)
  return if (fieldType.isSubclassOf(Map::class)) {
    (this as FirestoreMap).toMessageMap(builderType.getMapValueType(fieldName))
  } else {
    toMessageValue(fieldType)
  }
}

@Suppress("UNCHECKED_CAST")
private fun FirestoreValue.toMessageValue(targetType: KClass<*>): MessageValue =
  if (targetType == String::class) {
    this as String
  } else if (targetType.isSubclassOf(GeneratedMessageLite::class)) {
    (targetType as KClass<Message>).parseFrom(this as FirestoreMap)
  } else {
    throw UnsupportedOperationException("Unsupported message field type $targetType")
    // TODO(#1748): Handle arrays, GeoPoint, int, and other types.
  }
